= RESTful and Beyond - Building Services from the Ground Up
John D. Ament
:backend: dzslides
:dzslides-style: tomorrow
:dzslides-transition: horizontal-slide
:dzslides-fonts: family=Yanone+Kaffeesatz:400,700,200,300&family=Cedarville+Cursive
:dzslides-highlight: tomorrow-night-bright

[.topic.intro]
== Intro
[.incremental]
* Learn about microservices, deploying light weight applications
* Build using Java EE technologies in SE
* Leverage Apache DeltaSpike to build CDI based applications

== About Me

* Apache DeltaSpike PMC
* Software Architect @ Sparta Systems
* CDI 2.0 Expert Group Member
* Twitter @JohnAment

|===
| image:ds-logo.png[DeltaSpikeLogo, 200] | *real graphic pending*
|===

== The Technologies
[.incremental]
* *Java EE* Technologies
* Hibernate (JPA)
* JBoss Weld (CDI)
* Apache DeltaSpike (CDI Extensions)
* Apache CXF (JAX-WS)
* JBoss RestEasy (JAX-RS)
* JBoss Undertow (Servlet & WebSocket)
* Arquillian

== Container Control

* The ability to start a CDI container regardless of what impelementation you are using

[.topic.source]
== Startup.java

[source,java]
--
@Vetoed
public class Startup {
    public static void main(String[] args) {
        Startup startup = new Startup();
        startup.start();
    }

    public void start() {
        CdiContainer cdiContainer = CdiContainerLoader.getCdiContainer();
        cdiContainer.boot();
        cdiContainer.getContextControl().startContexts();

        registerShutdownHook(cdiContainer);

        CDI.current().getBeanManager().fireEvent(new ApplicationStartupEvent());
    }

    private void registerShutdownHook(CdiContainer cdiContainer) {
        Runtime.getRuntime().addShutdownHook(new Thread(cdiContainer::shutdown));
    }
}
--

== Context Control

* The ability to start and stop contexts on demand
* Useful in a filter here, to start a context dynamically.

[.topic.source]
== RequestScopedServletRequestListener.java

[source,java]
--
public class CDIRequestListener implements ServletRequestListener {
    @Override
    public void requestDestroyed(ServletRequestEvent e) {
        ((ContextControl)e.getServletRequest().getAttribute("rctx")).stopContext(RequestScoped.class);
    }

    @Override
    public void requestInitialized(ServletRequestEvent e) {
        ContextControl contextControl = CDI.current().select(ContextControl.class).get();
        e.getServletRequest().setAttribute("rctx", contextControl);
        contextControl.startContext(RequestScoped.class);
    }
}
--

== Extra Usecases

* You can also write an interceptor to start contexts on demand, based on method invocation.
* Excellent for WebSockets, which don't start Requests on demand

[.topic.source]
== RequestScopeInteceptor.java

[source,java]
--
@AroundInvoke
public Object startRequestScope(final InvocationContext ctx) throws Exception {
    Object result = null;
    ContextControl contextControl = null;
    if(!isRequestScopeActive()) {
        contextControl = CDI.current().select(ContextControl.class).get();
        contextControl.startContext(RequestScoped.class);
    }
    try {
        result = ctx.proceed();
    }
    finally {
        if(contextControl != null) {
            contextControl.stopContext(RequestScoped.class);
        }
    }
    return result;
}
--

== WebSockets Integration

[middle.right.incremental]
* WebSockets JSR has limited CDI integration
** Most work is *platform specific*
* No active contexts when methods are invoked
** Similar to MDBs
* Poor instance creation integration

[.topic.source]
== UndertowCDISupport.java

[source,java]
--
public class CDIClassIntrospecter implements ClassIntrospecter {
    public <T> InstanceFactory<T> createInstanceFactory(Class<T> aClass) throws NoSuchMethodException {
        return new CDIInstanceFactory<>(aClass);
    }
}

public class CDIInstanceFactory<T> implements InstanceFactory<T> {
    private Class<T> aClass;
    public CDIInstanceFactory(Class<T> aClass) {
        this.aClass = aClass;
    }
    public InstanceHandle<T> createInstance() throws InstantiationException {
        return new CDIInstanceHandle<>(aClass);
    }
}

public class CDIInstanceHandle<T> implements InstanceHandle<T> {
    private T instance;
    public CDIInstanceHandle(Class<T> aClass) {
        this.instance = CDI.current().select(aClass).get();
    }
    public T getInstance() {
        return instance;
    }
    public void release() { }
}
--

== WebSocket Enhancement

* Without these changes, instances of WebSockets (and Servlet) are managed by Undertow
* These factory classes replace how instances are resolved, leveraging scopes to manage scoping of instances

[.topic.source]
== ResponderServer.java

[source,java]
--
@ApplicationScoped
@ServerEndpoint("/serverSocket")
public class ResponderServer {
    @PostConstruct
    public void init() {
        System.out.println("Created server...");
    }
    @OnMessage
    @StartsRequestScope
    public void respond(String data, Session session) {
        System.out.println("Received "+data);
        try {
            CDI.current().select(RequestInvoker.class).get().inRequestScope();
            session.getBasicRemote().sendText("foo");

        } catch (Exception e) { }
    }
}
--

== WebSocket Enhancement

* This also works for clients
* Retrieving the instance via CDI, end up with a single per client program

[.topic.source]
== WebSocketTestClient.java

[source,java]
--
public Session connect(String uri) throws IOException, DeploymentException {
    WebSocketContainer webSocketContainer = ContainerProvider.getWebSocketContainer();
    URI endpointURI = URI.create(uri);
    return webSocketContainer.connectToServer(WebSocketTestClient.class,endpointURI);
}

public void send(String data, Session session) throws IOException {
    session.getBasicRemote().sendText(data);
}
--

== Servlet and WebSocket Review

* Use an introspector (Undertow specific) to control instance creation.
* Override the WebSocket container to

== Security Integration

* Interceptor based security
* Annotation based bindings
* Method based injection of dependencies

[.topic.source]
== Team1Authorizer.java

[source,java]
--
@RequestScoped
public class Team1Authorizer {
    @Secures
    @Team1Binding
    public boolean isAuthorizedForTeam1(InvocationContext invocationContext,
            User user) {
        return user.getGroups().stream().anyMatch("team1"::equalsIgnoreCase);
    }
}
--

== Security Overview
* Interceptor is invoked before the method is invoked.
* If it returns false, or throws an exception, the method is not invoked
* Typical approach is to bind the logged in user to a RequestScoped bean

== Persistence & Data Modules
* Simplified injection of JPA resources
* Transaction management
* Annotation and interface based querying support

== The Long Way
* Use `ConfigProperty` to specify parameters to load
* Manually start `EntityManagerFactory`
* Provide a producer method for your `EntityManager` and manage the transaction.

[.topic.source]
== LongPersistence.java

[source,java]
--
@PostConstruct
public void init() {
    Map<String,String> properties = new HashMap<>();
    properties.put("javax.persistence.jdbc.driver",driver);
    properties.put("javax.persistence.jdbc.url",url);
    properties.put("javax.persistence.jdbc.user",user);
    properties.put("javax.persistence.jdbc.password",password);
    properties.put("javax.persistence.schema-generation.database.action",schemaGen);
    entityManagerFactory = Persistence.createEntityManagerFactory("DefaultApp",properties);
}

@Produces
@RequestScoped
public EntityManager entityManager() {
    EntityManager em = entityManagerFactory.createEntityManager();
    EntityTransaction et = em.getTransaction();
    et.begin();
    return em;
}

public void cleanEM(@Disposes EntityManager entityManager) {
    EntityTransaction et = entityManager.getTransaction();
    if(et.getRollbackOnly()) {
        et.rollback();
    }
    else {
        et.commit();
    }
    entityManager.close();
}
--

== The Short Way
[.statement]
* Inject an `EntityManagerFactory` using `@PersistenceUnitName`
* DeltaSpike loads all properties in `persistence-UnitName.properties`
* Provide a producer method for your `EntityManager` and manage the transaction.

[.topic.source]
== ShortPersistence.java

[source,java]
--
@Inject
@PersistenceUnitName("DefaultApp")
private EntityManagerFactory entityManagerFactory;

@Produces
@RequestScoped
public EntityManager entityManager() {
    EntityManager em = entityManagerFactory.createEntityManager();
    EntityTransaction et = em.getTransaction();
    et.begin();
    return em;
}

public void cleanEM(@Disposes EntityManager entityManager) {
    EntityTransaction et = entityManager.getTransaction();
    if(et.getRollbackOnly()) {
        et.rollback();
    }
    else {
        et.commit();
    }
    entityManager.close();
}
--

== Transaction Management
[.statement]
* The other feature in persistence is transaction management
* Great for running in an application server where you have a `UserTransaction`
* Supports a `ResourceLocalTransactionStrategy` for use in SE mode
** Other options available for different deployment options

[.topic.source]
== TransactionPersistence.java

[source,java]
--
@Inject
@PersistenceUnitName("DefaultApp")
private EntityManagerFactory entityManagerFactory;

@Produces
@TransactionScoped
public EntityManager entityManager() {
    return entityManagerFactory.createEntityManager();
}

public void cleanEM(@Disposes EntityManager entityManager) {
    if(entityManager.isOpen()) {
        entityManager.close();
    }
}
--

== JPA Support
* Only necessary to provide a producer for your `EntityManager`
* Everything works out of the box

== Simple Querying Support
*

[.topic.ending]
== Thank you!

