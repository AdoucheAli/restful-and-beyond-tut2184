= RESTful and Beyond - Building Services from the Ground Up
John D. Ament
:backend: dzslides
:dzslides-style: tomorrow
:dzslides-transition: horizontal-slide
:dzslides-fonts: family=Yanone+Kaffeesatz:400,700,200,300&family=Cedarville+Cursive
:dzslides-highlight: tomorrow-night-bright

[.topic.intro]
== Intro
[.incremental]
* Learn about microservices, deploying light weight applications
* Build using Java EE technologies in SE
* Leverage Apache DeltaSpike to build CDI based applications

[.topic.intro]
== About Me

* Apache DeltaSpike PMC
* Software Architect @ Sparta Systems
* CDI 2.0 Expert Group Member
* Twitter @JohnAment

* Presentation content available at http://bit.ly/j1-tut2184

|===
| image:ds-logo.png[DeltaSpikeLogo, 200] | *real graphic pending*
|===

[.topic.intro]
== The Technologies
[.incremental]
* *Java EE* Technologies
* Hibernate (JPA)
* JBoss Weld (CDI)
* Apache DeltaSpike (CDI Extensions)
* JBoss RestEasy (JAX-RS)
* JBoss Undertow (Servlet & WebSocket)
* Arquillian

[.topic.intro]
== Container Control

* The ability to start a CDI container regardless of what impelementation you are using

[.topic.source]
== Startup.java

[source,java]
--
@Vetoed
public class Startup {
    public static void main(String[] args) {
        Startup startup = new Startup();
        startup.start();
    }

    public void start() {
        CdiContainer cdiContainer = CdiContainerLoader.getCdiContainer();
        cdiContainer.boot();
        cdiContainer.getContextControl().startContexts();

        registerShutdownHook(cdiContainer);

        CDI.current().getBeanManager()
            .fireEvent(new ApplicationStartupEvent());
    }

    private void registerShutdownHook(CdiContainer cdiContainer) {
        Runtime.getRuntime().addShutdownHook(
            new Thread(cdiContainer::shutdown));
    }
}
--

[.topic.intro]
== Context Control

* The ability to start and stop contexts on demand
* Useful in a filter here, to start a context dynamically.

[.topic.source]
== RequestScopedServletRequestListener.java

[source,java]
--
public class CDIRequestListener implements ServletRequestListener {
    @Override
    public void requestDestroyed(ServletRequestEvent e) {
        ((ContextControl)e.getServletRequest()
            .getAttribute("rctx"))
            .stopContext(RequestScoped.class);
    }

    @Override
    public void requestInitialized(ServletRequestEvent e) {
        ContextControl contextControl = CDI.current()
            .select(ContextControl.class).get();
        e.getServletRequest().setAttribute("rctx", contextControl);
        contextControl.startContext(RequestScoped.class);
    }
}
--

[.topic.intro]
== Extra Usecases

* You can also write an interceptor to start contexts on demand, based on method invocation.
* Excellent for WebSockets, which don't start Requests on demand

[.topic.source]
== RequestScopeInteceptor.java

[source,java]
--
@AroundInvoke
public Object startRequestScope(final InvocationContext ctx) throws Exception {
    Object result = null;
    ContextControl contextControl = null;
    if(!isRequestScopeActive()) {
        contextControl = CDI.current()
            .select(ContextControl.class).get();
        contextControl.startContext(RequestScoped.class);
    }
    try {
        result = ctx.proceed();
    }
    finally {
        if(contextControl != null) {
            contextControl.stopContext(RequestScoped.class);
        }
    }
    return result;
}
--

[.topic.intro]
== WebSockets Integration

[middle.right.incremental]
* WebSockets JSR has limited CDI integration
** Most work is *platform specific*
* No active contexts when methods are invoked
** Similar to MDBs
* Poor instance creation integration

[.topic.source]
== UndertowCDISupport.java

[source,java]
--
public class CDIClassIntrospecter implements ClassIntrospecter {
    public <T> InstanceFactory<T> createInstanceFactory(Class<T> aClass) throws NoSuchMethodException {
        return new CDIInstanceFactory<>(aClass);
    }
}

public class CDIInstanceFactory<T> implements InstanceFactory<T> {
    private Class<T> aClass;
    public CDIInstanceFactory(Class<T> aClass) {
        this.aClass = aClass;
    }
    public InstanceHandle<T> createInstance() throws InstantiationException {
        return new CDIInstanceHandle<>(aClass);
    }
}

public class CDIInstanceHandle<T> implements InstanceHandle<T> {
    private T instance;
    public CDIInstanceHandle(Class<T> aClass) {
        this.instance = CDI.current().select(aClass).get();
    }
    public T getInstance() {
        return instance;
    }
    public void release() { }
}
--

[.topic.intro]
== WebSocket Enhancement

* Without these changes, instances of WebSockets (and Servlet) are managed by Undertow
* These factory classes replace how instances are resolved, leveraging scopes to manage scoping of instances

[.topic.source]
== ResponderServer.java

[source,java]
--
@ApplicationScoped
@ServerEndpoint("/serverSocket")
public class ResponderServer {
    @OnMessage
    @StartsRequestScope
    public void respond(String data, Session session) {
        try {
            CDI.current().select(RequestInvoker.class)
                .get().inRequestScope();
            session.getBasicRemote().sendText("foo");
        } catch (Exception e) { }
    }
}
--

[.topic.intro]
== WebSocket Enhancement

* This also works for clients
* Retrieving the instance via CDI, end up with a single per client program

[.topic.source]
== WebSocketTestClient.java

[source,java]
--
public Session connect(String uri) throws IOException, DeploymentException {
    WebSocketContainer webSocketContainer =
        ContainerProvider.getWebSocketContainer();
    URI endpointURI = URI.create(uri);
    return webSocketContainer
        .connectToServer(WebSocketTestClient.class,endpointURI);
}

public void send(String data, Session session) throws IOException {
    session.getBasicRemote().sendText(data);
}
--

[.topic.intro]
== Servlet and WebSocket Review

* Use an introspector (Undertow specific) to control instance creation.
* Override the WebSocket container to

[.topic.intro]
== Security Integration

* Interceptor based security
* Annotation based bindings
* Method based injection of dependencies

[.topic.source]
== Team1Authorizer.java

[source,java]
--
@RequestScoped
public class Team1Authorizer {
    @Secures
    @Team1Binding
    public boolean isAuthorizedForTeam1(
        InvocationContext invocationContext,
        User user) {
        return user.getGroups().stream()
            .anyMatch("team1"::equalsIgnoreCase);
    }
}
--

[.topic.intro]
== Security Overview
* Interceptor is invoked before the method is invoked.
* If it returns false, or throws an exception, the method is not invoked
* Typical approach is to bind the logged in user to a RequestScoped bean

[.topic.intro]
== Persistence & Data Modules
* Simplified injection of JPA resources
* Transaction management
* Annotation and interface based querying support

[.topic.intro]
== The Long Way
* Use `ConfigProperty` to specify parameters to load
* Manually start `EntityManagerFactory`
* Provide a producer method for your `EntityManager` and manage the transaction.

[.topic.source]
== LongPersistence.java

[source,java]
--
@PostConstruct
public void init() {
    Map<String,String> properties = new HashMap<>();
    properties.put("javax.persistence.jdbc.driver",driver);
    properties.put("javax.persistence.jdbc.url",url);
    properties.put("javax.persistence.jdbc.user",user);
    properties.put("javax.persistence.jdbc.password",password);
    properties.put("javax.persistence.schema-generation.database.action",schemaGen);
    entityManagerFactory = Persistence.createEntityManagerFactory("DefaultApp",properties);
}
--

[.topic.intro]
== The Short Way
* Inject an `EntityManagerFactory` using `@PersistenceUnitName`
* DeltaSpike loads all properties in `persistence-UnitName.properties`
* Provide a producer method for your `EntityManager` and manage the transaction.

[.topic.source]
== ShortPersistence.java

[source,java]
--
@Inject
@PersistenceUnitName("DefaultApp")
private EntityManagerFactory entityManagerFactory;

@Produces
@RequestScoped
public EntityManager entityManager() {
    EntityManager em = entityManagerFactory.createEntityManager();
    EntityTransaction et = em.getTransaction();
    et.begin();
    return em;
}

public void cleanEM(@Disposes EntityManager entityManager) {
    EntityTransaction et = entityManager.getTransaction();
    if(et.getRollbackOnly()) {
        et.rollback();
    }
    else {
        et.commit();
    }
    entityManager.close();
}
--

[.topic.intro]
== Transaction Management
* The other feature in persistence is transaction management
* Great for running in an application server where you have a `UserTransaction`
* Supports Resource Local for use in SE mode by default
** Other options available for different deployment options

[.topic.source]
== TransactionPersistence.java

[source,java]
--
@Inject
@PersistenceUnitName("DefaultApp")
private EntityManagerFactory entityManagerFactory;

@Produces
@TransactionScoped
public EntityManager entityManager() {
    return entityManagerFactory.createEntityManager();
}

public void cleanEM(@Disposes EntityManager entityManager) {
    if(entityManager.isOpen()) {
        entityManager.close();
    }
}
--

[.topic.intro]
== JPA Support
* Only necessary to provide a producer for your `EntityManager`
* Everything works out of the box

[.topic.intro]
== Simple Querying Support
* Replaces DAOs
* Contains a lot of useful built in functionality

[.topic.source]
== EmployeeRepository.java

[source,java]
--
@Repository(forEntity = Employees.class)
public interface EmployeeRepository extends
    EntityRepository<Employees,Integer> { }
--

[.topic.intro]
== Application Startup
* Formally, in CDI, there is no concept of an eagerly instantiated bean
* You can do start up work in extensions (e.g. bind `EntityManagers` or HTTP connections)
* In CDI 1.0, only solution was to manually fire an event
* In CDI 1.1+ new `Initialized` to watch for the creation of scopes

[.topic.intro]
== Building a Real API
* We want to track all API requests in a separate database.
* Allow for crud operations against courses
* Notify consumers of new courses available
* Allow people to enroll for a course (free of charge!)
* Notify consumers when enrollment hits 5 for any course
* Don't allow new enrollment after 5 enrollees

[.topic.ending]
== Thank you!

